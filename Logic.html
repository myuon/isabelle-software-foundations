<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Logic (Isabelle2014: August 2014)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Logic</h1>

<span class="command">theory</span> <span class="name">Logic</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>

</div>
<div class="source">
<pre><span class="command">theory</span> Logic
<span class="keyword2">imports</span> Main
<span class="keyword2">begin</span>

<span class="comment">(* In Isabelle, Prop in Coq is just a type &#39;bool&#39;, then things are much easier *)</span>

<span class="command">section</span> <span class="verbatim">{* Logic *}</span>
<span class="command">subsection</span> <span class="verbatim">{* Propositions *}</span>

<span class="command">term</span> <span class="string">&quot;3 = 3&quot;</span>
  <span class="comment">(* ==&gt; &quot;3 = 3&quot; :: &quot;bool&quot; *)</span>
<span class="command">term</span> <span class="string">&quot;&forall;(n :: nat). n = 2&quot;</span>
  <span class="comment">(* ==&gt; &quot;&forall;n. n = 2&quot; :: &quot;bool&quot; *)</span>

<span class="command">subsection</span> <span class="verbatim">{* Proofs and Evidence *}</span>

<span class="command">lemma</span> silly<span class="delimiter">:</span> <span class="string">&quot;0 * 3 = (0 :: nat)&quot;</span> <span class="command">by</span> simp
<span class="command">thm</span> silly
  <span class="comment">(* ==&gt; 0 * 3 = 0 *)</span>

<span class="command">subsubsection</span> <span class="verbatim">{* Implications are functions *}</span>

<span class="command">lemma</span> silly_implication<span class="delimiter">:</span> <span class="string">&quot;(1 + 1) = 2 --&gt; 0 * 3 = (0 :: nat)&quot;</span> <span class="command">by</span> simp
<span class="command">thm</span> silly_implication
  <span class="comment">(* ==&gt; 1 + 1 = 2 --&gt; 0 * 3 = 0 *)</span>

<span class="command">subsubsection</span> <span class="verbatim">{* Defining Propositions *}</span>

<span class="command">subsection</span> <span class="verbatim">{* Conjunction (Logical &quot;and&quot;) *}</span>

<span class="comment">(*
Inductive and (P Q : Prop) : Prop :=
  conj : P -&gt; Q -&gt; (and P Q).
*)</span>

<span class="command">value</span> <span class="string">&quot;&lambda;x y. x &and; y&quot;</span>
  <span class="comment">(* ==&gt; &quot;_&quot; :: &quot;bool =&gt; bool =&gt; bool&quot; *)</span>

<span class="command">subsubsection</span> <span class="verbatim">{* &quot;Introducing&quot; Conjuctions *}</span>

<span class="command">theorem</span> and_example<span class="delimiter">:</span> <span class="string">&quot;((0 :: nat) = 0) &and; ((4 :: nat) = 2 * 2)&quot;</span> <span class="command">by</span> simp

<span class="command">subsubsection</span> <span class="verbatim">{* &quot;Eliminating&quot; conjunctions *}</span>

<span class="command">theorem</span> proj1<span class="delimiter">:</span> <span class="string">&quot;&forall;p q. p &and; q --&gt; p&quot;</span> <span class="command">by</span> simp

<span class="comment">(* Exercise: 1 star, optional (proj2) *)</span>

<span class="command">theorem</span> proj2<span class="delimiter">:</span> <span class="string">&quot;&forall;p q. p &and; q --&gt; q&quot;</span> <span class="command">by</span> simp
<span class="command">theorem</span> and_commut<span class="delimiter">:</span> <span class="string">&quot;&forall;p q. p &and; q --&gt; q &and; p&quot;</span> <span class="command">by</span> simp

<span class="comment">(* Exercise: 2 stars (and_assoc) *)</span>

<span class="command">theorem</span> and_assoc<span class="delimiter">:</span> <span class="string">&quot;&forall;p q r. p &and; (q &and; r) --&gt; (p &and; q) &and; r&quot;</span> <span class="command">by</span> simp

<span class="command">subsection</span> <span class="verbatim">{* Iff *}</span>

<span class="command">no_notation</span>
  iff <span class="delimiter">(</span><span class="keyword2">infixr</span> <span class="string">&quot;&lt;-&gt;&quot;</span> 25<span class="delimiter">)</span>

<span class="command">abbreviation</span> iff <span class="delimiter">(</span><span class="keyword2">infixr</span> <span class="string">&quot;&lt;-&gt;&quot;</span> 25<span class="delimiter">)</span> <span class="keyword2">where</span>
  <span class="string">&quot;iff p q &equiv; (p --&gt; q) &and; (q --&gt; p)&quot;</span>

<span class="command">theorem</span> iff_implies<span class="delimiter">:</span> <span class="string">&quot;&forall;p q. (p &lt;-&gt; q) --&gt; p --&gt; q&quot;</span> <span class="command">by</span> simp
<span class="command">theorem</span> iff_sym<span class="delimiter">:</span> <span class="string">&quot;&forall;p q. (p &lt;-&gt; q) --&gt; (q &lt;-&gt; p)&quot;</span> <span class="command">by</span> simp

<span class="comment">(* Exercise: 1 star, optional (iff_properties) *)</span>

<span class="command">theorem</span> iff_refl<span class="delimiter">:</span> <span class="string">&quot;&forall;p. p &lt;-&gt; p&quot;</span> <span class="command">by</span> simp
<span class="command">theorem</span> iff_trans<span class="delimiter">:</span> <span class="string">&quot;&forall;p q r. (p &lt;-&gt; q) --&gt; (q &lt;-&gt; r) --&gt; (p &lt;-&gt; r)&quot;</span> <span class="command">by</span> fastforce

<span class="command">subsection</span> <span class="verbatim">{* Disjunction (Logical &quot;or&quot;) *}</span>
<span class="command">subsubsection</span> <span class="verbatim">{* Implementing Disjunction *}</span>

<span class="comment">(*
Inductive or (P Q : Prop) : Prop :=
  | or_introl : P -&gt; or P Q
  | or_intror : Q -&gt; or P Q.
*)</span>

<span class="command">thm</span> <span class="string">&quot;disjI1&quot;</span>
  <span class="comment">(* ?P ==&gt; ?P &or; ?Q *)</span>
<span class="command">thm</span> <span class="string">&quot;disjI2&quot;</span>
  <span class="comment">(* ?Q ==&gt; ?P &or; ?Q *)</span>

<span class="command">theorem</span> or_commut<span class="delimiter">:</span> <span class="string">&quot;&forall;p q. p &or; q --&gt; q &or; p&quot;</span> <span class="command">by</span> simp
<span class="command">theorem</span> or_distributes_over_and_1<span class="delimiter">:</span> <span class="string">&quot;&forall;p q r. p &or; (q &and; r) --&gt; (p &or; q) &and; (p &or; r)&quot;</span> <span class="command">by</span> simp

<span class="comment">(* Exercise: 2 stars (or_distributes_over_and_2) *)</span>
<span class="command">theorem</span> or_distributes_over_and_2<span class="delimiter">:</span> <span class="string">&quot;&forall;p q r. (p &or; q) &and; (p &or; r) --&gt; p &or; (q &and; r)&quot;</span> <span class="command">by</span> auto

<span class="comment">(* Exercise: 1 star, optional (or_distributes_over_and) *)</span>
<span class="command">theorem</span> or_distributes_over_and <span class="delimiter">:</span> <span class="string">&quot;&forall;P Q R. P &or; (Q &and; R) &lt;-&gt; (P &or; Q) &and; (P &or; R)&quot;</span> <span class="command">by</span> auto

<span class="command">subsubsection</span> <span class="verbatim">{* Relating &and; and &or; with andb and orb (advanced) *}</span>

<span class="command">theorem</span> andb_prop<span class="delimiter">:</span> <span class="string">&quot;&forall;b c. b &and; c = True --&gt; b = True &and; c = True&quot;</span> <span class="command">by</span> simp
<span class="command">theorem</span> andb_true_intro<span class="delimiter">:</span> <span class="string">&quot;&forall;b c. b = True &and; c = True --&gt; b &and; c&quot;</span> <span class="command">by</span> simp

<span class="comment">(* Exercise: 2 stars, optional (bool_prop) *)</span>
<span class="command">theorem</span> andb_false<span class="delimiter">:</span> <span class="string">&quot;&forall;b c. b &and; c = False --&gt; b = False &or; c = False&quot;</span> <span class="command">by</span> simp
<span class="command">theorem</span> orb_prop<span class="delimiter">:</span> <span class="string">&quot;&forall;b c. b &or; c = True --&gt; b = True &or; c = True&quot;</span> <span class="command">by</span> simp
<span class="command">theorem</span> orb_false_elim<span class="delimiter">:</span> <span class="string">&quot;&forall;b c. (b &or; c) = False --&gt; b = False &and; c = False&quot;</span> <span class="command">by</span> simp

<span class="command">subsection</span> <span class="verbatim">{* Falsehood *}</span>

<span class="comment">(* Inductive False : Prop := . *)</span>

<span class="command">theorem</span> False_implies_nonsense<span class="delimiter">:</span> <span class="string">&quot;False --&gt; 2 + 2 = 5&quot;</span> <span class="command">by</span> simp
<span class="command">theorem</span> ex_falso_quodlibet<span class="delimiter">:</span> <span class="string">&quot;&forall;p. False --&gt; p&quot;</span> <span class="command">by</span> simp

<span class="command">subsubsection</span> <span class="verbatim">{* Truth *}</span>

<span class="comment">(* Exercise: 2 stars, advanced (True) *)</span>

<span class="command">subsection</span> <span class="verbatim">{* Negation *}</span>

<span class="comment">(* Definition not (P:Prop) := P -&gt; False. *)</span>

<span class="command">term</span> <span class="string">&quot;&lambda;x. &not; x&quot;</span>
  <span class="comment">(* ==&gt; &quot;Not&quot; :: &quot;bool =&gt; bool&quot; *)</span>

<span class="command">theorem</span> not_False<span class="delimiter">:</span> <span class="string">&quot;&not; False&quot;</span> <span class="command">by</span> simp
<span class="command">theorem</span> contradiction_implies_anything<span class="delimiter">:</span> <span class="string">&quot;&forall;p q. (p &and; &not; p) --&gt; q&quot;</span> <span class="command">by</span> simp
<span class="command">theorem</span> double_neg<span class="delimiter">:</span> <span class="string">&quot;&forall;p. p --&gt; ~~ p&quot;</span> <span class="command">by</span> simp

<span class="comment">(* Exercise: 2 stars, advanced (double_neg_inf) *)</span>
<span class="comment">(* Exercise: 2 stars (contrapositive) *)</span>

<span class="command">theorem</span> contrapositive<span class="delimiter">:</span> <span class="string">&quot;&forall;p q. (p --&gt; q) --&gt; (&not; q --&gt; &not; p)&quot;</span> <span class="command">by</span> auto

<span class="comment">(* Exercise: 1 star (not_both_true_and_false) *)</span>

<span class="command">theorem</span> <span class="string">&quot;&not; (p &and; &not; p)&quot;</span> <span class="command">by</span> simp

<span class="comment">(* Exercise: 1 star, advanced (informal_not_PNP) *)</span>

<span class="command">subsubsection</span> <span class="verbatim">{* Constructive logic *}</span>

<span class="command">theorem</span> classis_double_neg<span class="delimiter">:</span> <span class="string">&quot;~~ p --&gt; p&quot;</span> <span class="command">by</span> simp

<span class="comment">(* Exercise: 5 stars, advanced, optional (classical_axioms) *)</span>

<span class="command">abbreviation</span> <span class="string">&quot;peirce &equiv; &forall;p q. ((p --&gt; q) --&gt; p) --&gt; p&quot;</span>
<span class="command">abbreviation</span> <span class="string">&quot;classic &equiv; &forall;p. ~~p --&gt; p&quot;</span>
<span class="command">abbreviation</span> <span class="string">&quot;excluded_middle &equiv; &forall;p. p &or; &not; p&quot;</span>
<span class="command">abbreviation</span> <span class="string">&quot;de_morgan_not_and_not &equiv; &forall;p q. &not; (&not; p &and; &not; q) --&gt; p &or; q&quot;</span>
<span class="command">abbreviation</span> <span class="string">&quot;implies_to_or &equiv; &forall;p q. (p --&gt; q) --&gt; (&not; p &or; q)&quot;</span>

<span class="comment">(* Exercise: 3 stars (excluded_middle_irrefutable) *)</span>

<span class="command">theorem</span> excluded_middle_irrefutable<span class="delimiter">:</span> <span class="string">&quot;&forall;p. &not; &not; (p &or; &not; p)&quot;</span> <span class="command">by</span> simp

<span class="command">subsubsection</span> <span class="verbatim">{* Inequality *}</span>

<span class="command">theorem</span> not_false_then_true<span class="delimiter">:</span> <span class="string">&quot;&forall;b. b &ne; False --&gt; b = True&quot;</span> <span class="command">by</span> simp

<span class="comment">(* Exercise: 2 stars (false_beq_nat) *)</span>

<span class="command">theorem</span> false_beq_nat<span class="delimiter">:</span> <span class="string">&quot;&forall;n m. n &ne; m --&gt; n = m = False&quot;</span> <span class="command">by</span> simp

<span class="comment">(* Exercise: 2 stars, optional (beq_nat_false) *)</span>

<span class="command">theorem</span> beq_nat_false<span class="delimiter">:</span> <span class="string">&quot;&forall;n m. n = m = False --&gt; n &ne; m&quot;</span> <span class="command">by</span> simp

<span class="command">end</span>
</pre>

</div>
</body>
</html>
